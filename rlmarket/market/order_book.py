"""
This is the implementation of the full order book. We differentiate between real orders and user orders here
* Real orders are what being reconstructed from ITCH files and should be well-behaved (no cross the book for example)
* User orders are what being generated by the agent. To make sure we faithfully reconstruct real orders, we use
    the following matching rules:
    1. User limit orders are fully executed once being run over. Real environment order will not match against it though
    2. User environment orders are executed at the volume weighted price. It is not actually matched against real limit
        order though
    3. Agent should make sure it does not execute against its own orders

Convention of ITCH data:
* Order ID of MarketOrder, CancelOrder and DeleteOrder is the ID of the referenced LimitOrder
"""
from typing import Dict, Tuple, List

from rlmarket.market.book import Book
from rlmarket.market.order import LimitOrder, MarketOrder, CancelOrder, DeleteOrder, UpdateOrder


class OrderBook:
    """ Full order book with both ask and bid sides """

    def __init__(self) -> None:
        # Bid book is in descending order
        self.bid_book = Book('B', lambda x: -x)
        # Ask book is in ascending order. None is default for ascending ordering
        self.ask_book = Book('S', None)
        # Store mapping from order to book and price level
        self.order_pool: Dict[int, Book] = {}

    # ========== Order Operations ==========
    def add_limit_order(self, order: LimitOrder) -> None:
        """ Add real limit order to the book """
        if order.id in self.order_pool:
            raise RuntimeError(f'LimitOrder ID {order.id} already exists')

        if order.side == 'B':
            if not self.ask_book.quote or order.price < self.ask_book.quote:
                self._add_limit_order_to_book(order, self.bid_book)
            else:
                # Under the user order matching logic, we should not need to cross the book
                raise RuntimeError(f'Buy limit order of price {order.price} '
                                   f'cross to the ask book with quote of {self.ask_book.quote}')
        else:
            if not self.bid_book.quote or order.price > self.bid_book.quote:
                self._add_limit_order_to_book(order, self.ask_book)
            else:
                # Under the user order matching logic, we should not need to cross the book
                raise RuntimeError(f'Sell limit order of price {order.price} '
                                   f'cross to the bid book with quote of {self.bid_book.quote}')

    def match_limit_order(self, market_order: MarketOrder) -> None:
        """ Match environment in the correct book """
        if self.order_pool[market_order.id].match_limit_order(market_order):
            del self.order_pool[market_order.id]  # If limit order is exhausted, remove from pool

    def cancel_order(self, order: CancelOrder) -> None:
        """ CancelOrder should not exhausted the referenced LimitOrder """
        self.order_pool[order.id].cancel_order(order)

    def delete_order(self, order: DeleteOrder) -> None:
        """ Remove order from book """
        self.order_pool[order.id].delete_order(order)
        del self.order_pool[order.id]

    def modify_order(self, order: UpdateOrder) -> None:
        """ UpdateOrder only happens on the same side of book """
        book = self.order_pool[order.old_id]
        book.delete_order(DeleteOrder(order.timestamp, order.old_id))
        self._add_limit_order_to_book(LimitOrder(order.timestamp, order.id, book.side, order.price, order.shares), book)

    # ========== Private Methods ==========
    def _add_limit_order_to_book(self, order: LimitOrder, book: Book) -> None:
        """ Add limit order to book and record reference """
        book.add_limit_order(order)
        self.order_pool[order.id] = book

    # ========== Properties ==========
    @property
    def quote(self) -> Tuple[int, int]:
        return self.bid_book.quote, self.ask_book.quote

    def get_depth(self, num_levels: int = 5) -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]]]:
        return self.bid_book.get_depth(num_levels), self.ask_book.get_depth(num_levels)
