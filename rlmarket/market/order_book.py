"""
This is the implementation of the full order book. We differentiate between real orders and user orders here
* Real orders are what being reconstructed from ITCH files and should be well-behaved (no cross the book for example)
* User orders are what being generated by the agent. To make sure we faithfully reconstruct real orders, we use
    the following matching rules:
    1. User limit orders are fully executed once being run over. Real environment order will not match against it though
    2. User environment orders are executed at the volume weighted price. It is not actually matched against real limit
        order though
    3. Agent should make sure it does not execute against its own orders

Convention of ITCH data:
* Order ID of MarketOrder, CancelOrder and DeleteOrder is the ID of the referenced LimitOrder
"""
from typing import Dict, Tuple, List

from rlmarket.market.book import Book
from rlmarket.market.order import LimitOrder, MarketOrder, CancelOrder, DeleteOrder, UpdateOrder
from rlmarket.market.user_order import UserLimitOrder, UserMarketOrder, Execution


class OrderBook:
    """ Full order book with both ask and bid sides """

    def __init__(self) -> None:
        # Bid book is in descending order
        self.bid_book = Book('B', lambda x: -x)
        # Ask book is in ascending order. None is default for ascending ordering
        self.ask_book = Book('S', None)
        # Store mapping from order to book and price level
        self.order_pool: Dict[int, Book] = {}

    def reset(self):
        self.order_pool.clear()
        self.bid_book.reset()
        self.ask_book.reset()

    # ========== Order Operations ==========
    def add_limit_order(self, order: LimitOrder) -> List[Execution]:
        """ Add real limit order to the book """
        if order.id in self.order_pool:
            raise RuntimeError(f'LimitOrder ID {order.id} already exists')

        if order.side == 'B':
            if not self.ask_book.quote or order.price < self.ask_book.quote:
                # Execute user order price levels where needed
                self._add_limit_order_to_book(order, self.bid_book)
                # When ask book is not empty, need to make sure to resolve book crossing
                return self.ask_book.resolve_limit_order_crossing(order.price)
            else:
                # Under the user order matching logic, we should not need to cross the book
                raise RuntimeError(f'Buy limit order of price {order.price} '
                                   f'cross to the ask book with quote of {self.ask_book.quote}')
        else:
            if not self.bid_book.quote or order.price > self.bid_book.quote:
                self._add_limit_order_to_book(order, self.ask_book)
                return self.bid_book.resolve_limit_order_crossing(order.price)
            else:
                # Under the user order matching logic, we should not need to cross the book
                raise RuntimeError(f'Sell limit order of price {order.price} '
                                   f'cross to the bid book with quote of {self.bid_book.quote}')

    def match_limit_order(self, market_order: MarketOrder) -> List[Execution]:
        """ Match environment in the correct book """
        exhausted, executions = self.order_pool[market_order.id].match_limit_order(market_order)
        if exhausted:
            del self.order_pool[market_order.id]  # If limit order is exhausted, remove from pool
        return executions

    def cancel_order(self, order: CancelOrder) -> None:
        """ CancelOrder should not exhausted the referenced LimitOrder """
        self.order_pool[order.id].cancel_order(order)

    def delete_order(self, order: DeleteOrder) -> None:
        """ Remove order from book """
        self.order_pool[order.id].delete_order(order)
        del self.order_pool[order.id]

    def modify_order(self, order: UpdateOrder) -> None:
        """ UpdateOrder only happens on the same side of book """
        book = self.order_pool[order.old_id]
        book.delete_order(DeleteOrder(order.timestamp, order.old_id))
        self._add_limit_order_to_book(LimitOrder(order.timestamp, order.id, book.side, order.price, order.shares), book)

    # ========== User Order Operations ==========
    def add_user_limit_order(self, order: UserLimitOrder) -> None:
        """
        Add user LimitOrder to the book.
        Logic mostly copied from add_limit_user except that we do not raises, but simply ignore
        """
        if order.id in self.order_pool:
            raise RuntimeError(f'LimitOrder ID {order.id} already exists')

        if order.side == 'B':
            if not self.ask_book.quote or order.price < self.ask_book.quote:
                book = self.bid_book
            else:
                raise RuntimeError(f'Bid order crosses the book')

        elif order.side == 'S':
            if not self.bid_book.quote or order.price > self.bid_book.quote:
                book = self.ask_book
            else:
                raise RuntimeError('Ask order crosses the book')

        else:
            raise ValueError(f'Unrecognized side {order.side}')

        if book.add_user_limit_order(order):
            # Existing order may have higher time priority, in which case we should not replace it with the new one
            self.order_pool[order.id] = book

    def match_limit_order_for_user(self, order: UserMarketOrder) -> Execution:
        """ Execute user MarketOrder in the correct book """
        if order.side == 'B':
            return self.ask_book.match_limit_order_for_user(order)
        elif order.side == 'S':
            return self.bid_book.match_limit_order_for_user(order)
        else:
            raise ValueError(f'Unrecognized side {order.side}')

    # def delete_user_order(self, order: UserLimitOrder):
    #     """ Remove user order """
    #     self.order_pool[order.id].delete_user_order(order)
    #     del self.order_pool[order.id]

    # ========== Private Methods ==========
    def _add_limit_order_to_book(self, order: LimitOrder, book: Book) -> None:
        """ Add limit order to book and record reference """
        book.add_limit_order(order)
        self.order_pool[order.id] = book

    # ========== Properties ==========
    @property
    def quote(self) -> Tuple[int, int]:
        return self.bid_book.quote, self.ask_book.quote

    @property
    def mid_price(self) -> int:
        bid, ask = self.quote
        return int((bid + ask) / 2)

    @property
    def spread(self) -> int:
        bid, ask = self.quote
        return ask - bid

    @property
    def imbalance(self) -> float:
        bid_volume = self.bid_book.volume
        ask_volume = self.ask_book.volume
        return (bid_volume - ask_volume) / (bid_volume + ask_volume)

    def get_depth(self, num_levels: int = 5) -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]]]:
        return self.bid_book.get_depth(num_levels), self.ask_book.get_depth(num_levels)
